{"ts":1370055403314,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"(function(){\n\tvar namespace = com.mordritch.mcSim;\n\tvar parentFunc = \"BlockType_Block\";\n\tvar funcName = \"BlockType_RedstoneRepeater\";\n\t\n\tnamespace[funcName] = function() {};\n\tnamespace[funcName].prototype = new namespace[parentFunc]();\n\tvar proto = namespace[funcName].prototype;\n\t\n\tproto.material = \"circuits\";\n\tproto.repeaterState = new Array(1,2,3,4);\n\t\n\tproto.construct = function() {\n\t\tthis._renderAsNormalBlock = false;\n\t\t\n\t\tif (this.blockType == \"redstoneRepeaterActive\") {\n\t\t\tthis.isRepeaterPowered = true;\n\t\t}\n\t\t\n\t\tif (this.blockType == \"redstoneRepeaterIdle\") {\n\t\t\tthis.isRepeaterPowered = false;\n\t\t}\n\t}\n\t\n\tproto.isIndirectlyPoweringTo = function(world, posX, posY, posZ, direction) {\n\t\treturn this.isPoweringTo(world, posX, posY, posZ, direction);\n\t}\n\t\n\tproto.toggleBlock = function(world, posX, posY, posZ) {\n\t\tthis.blockActivated(world, posX, posY, posZ);\n\t\tworld.markBlocksDirty(posX, posY, posZ, posX, posY, posZ);\n\t}\n\t\n\tproto.rotateSelection = function(blockMetadata, amount) {\n\t\tvar facing = blockMetadata & 0x3;\n\t\tvar delay = blockMetadata & 0xc;\n\t\tfor (var i=0; i<amount; i++) {\n\t\t\tfacing = new Array(1, 2, 3, 0)[facing];\n\t\t}\n\t\treturn facing | delay;\n\t}\n\t\n\tproto.rotateBlock = function(world, posX, posY, posZ) {\n\t\tvar blockMetadata = world.getBlockMetadata(posX, posY, posZ);\n\t\tvar repeaterOrientation = blockMetadata & 0x3;\n\t\trepeaterOrientation = (repeaterOrientation + 1) & 0x3;\n\t\tworld.setBlockAndMetadataWithNotify(posX, posY, posZ, this.blockID, repeaterOrientation | (blockMetadata & 0xc));\n\t}\n\t\n\tproto.blockActivated = function(world, posX, posY, posZ) {\n\t\tvar blockMetadata = world.getBlockMetadata(posX, posY, posZ);\n\t\tvar repeaterDelay = (blockMetadata & 0xc) >> 0x2;\n\t\trepeaterDelay = repeaterDelay + 1 << 0x2 & 0xc;\n\t\tworld.setBlockMetadataWithNotify(posX, posY, posZ, repeaterDelay | blockMetadata & 0x3);\n\t\treturn true;\n\t}\n\t\n\tproto.canPlaceBlockAt = function(world, posX, posY, posZ) {\n\t\treturn world.isBlockNormalCube(posX, posY - 1, posZ);\n\t}\n\n\tproto.canBlockStay = function(world, posX, posY, posZ) {\n\t\treturn this.canPlaceBlockAt(world, posX, posY, posZ);\n\t}\n\n\tproto.onBlockAdded = function (world, posX, posY, posZ)\n\t{\n\t\tworld.notifyBlocksOfNeighborChange(posX + 1, posY, posZ, blockID);\n\t\tworld.notifyBlocksOfNeighborChange(posX - 1, posY, posZ, blockID);\n\t\tworld.notifyBlocksOfNeighborChange(posX, posY, posZ + 1, blockID);\n\t\tworld.notifyBlocksOfNeighborChange(posX, posY, posZ - 1, blockID);\n\t\tworld.notifyBlocksOfNeighborChange(posX, posY - 1, posZ, blockID);\n\t\tworld.notifyBlocksOfNeighborChange(posX, posY + 1, posZ, blockID);\n\t}\n\t\n\tproto.isPoweringTo = function(world, posX, posY, posZ, direction) {\n\t\tif (!this.isRepeaterPowered) {\n\t\t\treturn false;\n\t\t}\n\t\tvar repeaterDirection = world.getBlockMetadata(posX, posY, posZ) & 3;\n\t\t\n\t\tif (repeaterDirection == 0 && direction == 3) {\n\t\t\treturn true;\n\t\t}\n\t\tif (repeaterDirection == 1 && direction == 4) {\n\t\t\treturn true;\n\t\t}\n\t\tif (repeaterDirection == 2 && direction == 2) {\n\t\t\treturn true;\n\t\t}\n\t\treturn repeaterDirection == 3 && direction == 5;\n\t}\n\t\n\tproto.onNeighborBlockChange = function(world, posX, posY, posZ, direction) {\n\t\tif (!this.canBlockStay(world, posX, posY, posZ)) {\n\t\t\t//dropBlockAsItem(world, posX, posY, posZ, world.getBlockMetadata(posX, posY, posZ), 0); //NA for the simulator\n\t\t\tworld.setBlockWithNotify(posX, posY, posZ, 0);\n\t\t\treturn;\n\t\t}\n\t\tvar blockMetadata = world.getBlockMetadata(posX, posY, posZ);\n\t\tvar ignoreTick = this.ignoreTick(world, posX, posY, posZ, blockMetadata);\n\t\tvar repeaterDelay = (blockMetadata & 0xc) >> 2;\n\t\tif (this.isRepeaterPowered && !ignoreTick) {\n\t\t\tworld.scheduleBlockUpdate(posX, posY, posZ, this.blockID, this.repeaterState[repeaterDelay] * 2);\n\t\t}\n\t\telse if (!this.isRepeaterPowered && ignoreTick) {\n\t\t\tworld.scheduleBlockUpdate(posX, posY, posZ, this.blockID, this.repeaterState[repeaterDelay] * 2);\n\t\t}\n\t}\n\t\n\tproto.ignoreTick = function (world, posX, posY, posZ, blockMetadata) {\n\t\tvar repeaterDirection= blockMetadata & 3;\n\t\tswitch (repeaterDirection) {\n\t\t\tcase 0:\n\t\t\t\treturn world.isBlockIndirectlyProvidingPowerTo(posX, posY, posZ + 1, 3) || world.getBlockId(posX, posY, posZ + 1) == world.Block.redstoneWire.blockID && world.getBlockMetadata(posX, posY, posZ + 1) > 0;\n\n\t\t\tcase 2:\n\t\t\t\treturn world.isBlockIndirectlyProvidingPowerTo(posX, posY, posZ - 1, 2) || world.getBlockId(posX, posY, posZ - 1) == world.Block.redstoneWire.blockID && world.getBlockMetadata(posX, posY, posZ - 1) > 0;\n\n\t\t\tcase 3:\n\t\t\t\treturn world.isBlockIndirectlyProvidingPowerTo(posX + 1, posY, posZ, 5) || world.getBlockId(posX + 1, posY, posZ) == world.Block.redstoneWire.blockID && world.getBlockMetadata(posX + 1, posY, posZ) > 0;\n\n\t\t\tcase 1:\n\t\t\t\treturn world.isBlockIndirectlyProvidingPowerTo(posX - 1, posY, posZ, 4) || world.getBlockId(posX - 1, posY, posZ) == world.Block.redstoneWire.blockID && world.getBlockMetadata(posX - 1, posY, posZ) > 0;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tproto.updateTick = function(world, posX, posY, posZ) {\n\t\tvar blockMetadata = world.getBlockMetadata(posX, posY, posZ);\n\t\tvar ignoreTick = this.ignoreTick(world, posX, posY, posZ, blockMetadata);\n\t\tif (this.isRepeaterPowered && !ignoreTick) {\n\t\t\tworld.setBlockAndMetadataWithNotify(posX, posY, posZ, world.Block.redstoneRepeaterIdle.blockID, blockMetadata);\n\t\t}\n\t\telse if (!this.isRepeaterPowered) {\n\t\t\tworld.setBlockAndMetadataWithNotify(posX, posY, posZ, world.Block.redstoneRepeaterActive.blockID, blockMetadata);\n\t\t\tif (!ignoreTick) {\n\t\t\t\tvar repeaterDelay = (blockMetadata & 0xc) >> 2;\n\t\t\t\tworld.scheduleBlockUpdate(posX, posY, posZ, world.Block.redstoneRepeaterActive.blockID, this.repeaterState[repeaterDelay] * 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tproto.drawTopView_currentLayer = function(world, posX, posY, posZ, canvas) {\n\t\tthis.drawTopView_generic(world, posX, posY, posZ, canvas);\n\t}\n\t\t\n\tproto.drawTopView_aboveLayer = function(world, posX, posY, posZ, canvas) {\n\t\tthis.drawTopView_generic(world, posX, posY, posZ, canvas);\n\t}\n\t\n\tproto.drawTopView_generic = function(world, posX, posY, posZ, canvas) {\n\t\tvar blockMetaData = world.getBlockMetadata(posX, posY, posZ);\n\t\t\n\t\t/*\n\t\tLow (1st & 2nd) bits:\n\t\t0x0: Facing north\n\t\t0x1: Facing east\n\t\t0x2: Facing south\n\t\t0x3: Facing west\n\t\t*/\n\t\tvar facing = blockMetaData & 0x3;\n\t\t\n\t\tswitch (facing) {\n\t\t\tcase 0:\n\t\t\t\tthis.draw(world, posX, posY, posZ, canvas, \"top\", 0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.draw(world, posX, posY, posZ, canvas, \"top\", 90);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.draw(world, posX, posY, posZ, canvas, \"top\", 180);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.draw(world, posX, posY, posZ, canvas, \"top\", 270);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tproto.drawSideView_currentLayer = function(world, posX, posY, posZ, canvas, lookingTowards) {\n\t\tvar blockMetaData = world.getBlockMetadata(posX, posY, posZ);\n\t\tvar facing = blockMetaData & 0x3;\n\n\t\tvar view;\n\t\tvar rotated = 0;\n\t\tvar mirrored = false;\n\t\tvar\n\t\t\tLOOKING_TOWARDS_NORTH = 0,\n\t\t\tLOOKING_TOWARDS_EAST = 1,\n\t\t\tLOOKING_TOWARDS_SOUTH = 2,\n\t\t\tLOOKING_TOWARDS_WEST = 3,\n\t\t\tFACING_NORTH = 0,\n\t\t\tFACING_EAST = 1,\n\t\t\tFACING_SOUTH = 2,\n\t\t\tFACING_WEST = 3;\n\t\t\n\t\tswitch (lookingTowards) {\n\t\t\tcase LOOKING_TOWARDS_SOUTH:\n\t\t\t\tswitch (facing) {\n\t\t\t\t\tcase FACING_EAST:\n\t\t\t\t\t\tview = \"side\";\n\t\t\t\t\t\tmirrored = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_SOUTH:\n\t\t\t\t\t\tview = \"top\";\n\t\t\t\t\t\trotated = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_WEST:\n\t\t\t\t\t\tview = \"side\";\n\t\t\t\t\t\tmirrored = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_NORTH:\n\t\t\t\t\t\tview = \"top\";\n\t\t\t\t\t\trotated = 180;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LOOKING_TOWARDS_NORTH:\n\t\t\t\tswitch (facing) {\n\t\t\t\t\tcase FACING_EAST:\n\t\t\t\t\t\tview = \"side\";\n\t\t\t\t\t\tmirrored = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_SOUTH:\n\t\t\t\t\t\tview = \"top\";\n\t\t\t\t\t\trotated = 180;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_WEST:\n\t\t\t\t\t\tview = \"side\";\n\t\t\t\t\t\tmirrored = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_NORTH:\n\t\t\t\t\t\tview = \"top\";\n\t\t\t\t\t\trotated = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LOOKING_TOWARDS_WEST:\n\t\t\t\tswitch (facing) {\n\t\t\t\t\tcase FACING_EAST:\n\t\t\t\t\t\tview = \"top\";\n\t\t\t\t\t\trotated = 180;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_SOUTH:\n\t\t\t\t\t\tview = \"side\";\n\t\t\t\t\t\tmirrored = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_WEST:\n\t\t\t\t\t\tview = \"top\";\n\t\t\t\t\t\trotated = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_NORTH:\n\t\t\t\t\t\tview = \"side\";\n\t\t\t\t\t\tmirrored = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LOOKING_TOWARDS_EAST:\n\t\t\t\tswitch (facing) {\n\t\t\t\t\tcase FACING_EAST:\n\t\t\t\t\t\tview = \"top\";\n\t\t\t\t\t\trotated = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_SOUTH:\n\t\t\t\t\t\tview = \"side\";\n\t\t\t\t\t\tmirrored = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_WEST:\n\t\t\t\t\t\tview = \"top\";\n\t\t\t\t\t\trotated = 180;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FACING_NORTH:\n\t\t\t\t\t\tview = \"side\";\n\t\t\t\t\t\tmirrored = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tproto.draw(world, posX, posY, posZ, canvas, view, rotated, mirrored);\n\t}\n\n\tproto.draw = function(world, posX, posY, posZ, canvas, view, rotated, mirrored) {\n\t\tvar poweredColour = \"rgb(255,0,0)\";\n\t\tvar unpoweredColour = \"rgb(128,0,0)\";\n\t\tvar unusedColour = \"rgb(192,192,192)\";\n\t\tvar blockMetaData = world.getBlockMetadata(posX, posY, posZ);\n\t\t\n \t\t/*\n \t\tHigh (3rd & 4th) bits:\n\t\t0x0: 1 tick delay\n\t\t0x1: 2 tick delay\n\t\t0x2: 3 tick delay\n\t\t0x3: 4 tick delay\n\t\t*/\n\t\tvar delay = (blockMetaData >>> 2) + 1;\n\t\t\n\t\tvar delayColour1 = (this.isRepeaterPowered) ? poweredColour : unpoweredColour;\n\t\tvar delayColour2 = (this.isRepeaterPowered) ? poweredColour : unpoweredColour;\n\t\tvar delayColour3 = (this.isRepeaterPowered) ? poweredColour : unpoweredColour;\n\t\tvar delayColour4 = (this.isRepeaterPowered) ? poweredColour : unpoweredColour;\n\t\t\n\t\tvar delayColour2 = (delay >= 2) ? delayColour2 : unusedColour;\n\t\tvar delayColour3 = (delay >= 3) ? delayColour3 : unusedColour;\n\t\tvar delayColour4 = (delay >= 4) ? delayColour4 : unusedColour;\n\t\t\n\t\tif (view == \"top\") {\n\t\t\tcanvas.save();\n\t\t\tthis.rotateContext(rotated, canvas);\n\n\t\t\tcanvas.fillStyle = delayColour1\n\t\t\tcanvas.fillRect(3, 0, 2, 2);\n\n\t\t\tif (delayColour2 != delayColour1) {\n\t\t\t\tcanvas.fillStyle = delayColour2;\n\t\t\t}\n\t\t\tcanvas.fillRect(2, 2, 4, 2);\n\n\t\t\tif (delayColour3 != delayColour2) {\n\t\t\t\tcanvas.fillStyle = delayColour3;\n\t\t\t}\n\t\t\tcanvas.fillRect(1, 4, 6, 2);\n\n\t\t\tif (delayColour4 != delayColour3) {\n\t\t\t\tcanvas.fillStyle = delayColour4;\n\t\t\t}\n\t\t\tcanvas.fillRect(0, 6, 8, 2);\n\n\t\t\tcanvas.restore();\n\t\t}\n\t\t\n\t\tif (view == \"side\") {\n\t\t\tif (mirrored) {\n\t\t\t\tcanvas.save();\n\t\t\t\tcanvas.translate(8, 0);\n\t\t\t\tcanvas.scale(-1, 1);\n\t\t\t}\n\t\t\t\n\t\t\tcanvas.fillStyle = delayColour1\n\t\t\tcanvas.fillRect(0, 6, 2, 2);\n\n\t\t\tif (delayColour2 != delayColour1) {\n\t\t\t\tcanvas.fillStyle = delayColour2;\n\t\t\t}\n\t\t\tcanvas.fillRect(2, 5, 2, 3);\n\n\t\t\tif (delayColour3 != delayColour2) {\n\t\t\t\tcanvas.fillStyle = delayColour3;\n\t\t\t}\n\t\t\tcanvas.fillRect(4, 4, 2, 4);\n\n\t\t\tif (delayColour4 != delayColour3) {\n\t\t\t\tcanvas.fillStyle = delayColour4;\n\t\t\t}\n\t\t\tcanvas.fillRect(6, 3, 2, 5);\n\n\t\t\tif (mirrored) {\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\t\t}\n\t}\n\n\tproto.enumeratePlaceableBlocks = function() {\n\t\tif (this.blockType == \"redstoneRepeaterIdle\") {\n\t\t\treturn new Array(\n\t\t\t\t{\n\t\t\t\t\tblockID: this.blockID,\n\t\t\t\t\tblockMetadata: 0,\n\t\t\t\t\tblockType: this.blockType,\n\t\t\t\t\tblockName: this.getBlockName(0),\n\t\t\t\t\tmaterial: this.material\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn new Array();\n\t\t}\n\t}\n}());\n"]],"start1":0,"start2":0,"length1":0,"length2":11076}]],"length":11076}
